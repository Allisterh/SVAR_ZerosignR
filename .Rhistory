LR = FALSE, tries = 1000)
zerosign_restr_bvar <- zerosign_restr.bvar(bvar_model,
restr_matrix = signs,
LR = FALSE, tries = 1000)
bvar_model <- bvar(data_to_model, lags=1,
priors = bv_priors(),
mh = bv_mh(),
n_thin=10, n_burn=5000, n_draw=15000)
zerosign_restr_bvar <- zerosign_restr.bvar(bvar_model,
restr_matrix = signs,
LR = FALSE, tries = 1000)
signs_test <- array(dim=c(5,5,1))
signs_test <- signs[,,1]
signs_test
zerosign_restr_bvar <- zerosign_restr.bvar(bvar_model,
restr_matrix = signs_test,
LR = FALSE, tries = 1000)
zerosign_restr_bvar <- zerosign_restr.bvar(bvar_model,
restr_matrix = signs_test,
LR = FALSE, tries = 1000)
signs_test
signs_test <- array(dim=c(5,5,1))
signs_test[,,1] <- signs[,,1]
zerosign_restr_bvar <- zerosign_restr.bvar(bvar_model,
restr_matrix = signs_test,
LR = FALSE, tries = 1000)
View(data_to_model)
data_to_model$neer_qoq <- data_to_model$neer_qoq*-1
bvar_model <- bvar(data_to_model, lags=1,
priors = bv_priors(),
mh = bv_mh(),
n_thin=10, n_burn=5000, n_draw=15000)
var_model <- VAR(data_to_model, p = 1, type = "const")
zerosign_restr_bvar <- zerosign_restr.bvar(bvar_model,
restr_matrix = signs,
LR = FALSE, tries = 1000)
View(data_to_model)
data_to_model <- read.csv("data/russian_data.csv")
View(data_to_model)
data_to_model <- data_to_model[,-1]
data_to_model$neer_qoq <- data_to_model$neer_qoq*-1
data_to_model
bvar_model <- bvar(data_to_model, lags=1,
priors = bv_priors(),
mh = bv_mh(),
n_thin=10, n_burn=5000, n_draw=15000)
var_model <- VAR(data_to_model, p = 1, type = "const")
zerosign_restr_bvar <- zerosign_restr.bvar(bvar_model,
restr_matrix = signs_test,
LR = FALSE, tries = 1000)
zerosign_restr_bvar <- zerosign_restr.bvar(bvar_model,
restr_matrix = signs,
LR = FALSE, tries = 1000)
signs_test
signs_test <- array(dim=c(5,5,2))
diag(signs_test[,,1]) <- 1
diag(signs_test[,,2]) <- 1
zerosign_restr_bvar <- zerosign_restr.bvar(bvar_model,
restr_matrix = signs_test,
LR = FALSE, tries = 1000)
zerosign_restr_bvar <- zerosign_restr.bvar(bvar_model,
restr_matrix = signs,
LR = FALSE, tries = 5000)
bvar_model <- bvar(data_to_model, lags=1,
priors = bv_priors(),
mh = bv_mh(),
n_thin=5, n_burn=5000, n_draw=15000)
zerosign_restr_bvar <- zerosign_restr.bvar(bvar_model,
restr_matrix = signs,
LR = FALSE, tries = 1000)
set.seed(42)
bvar_model <- bvar(data_to_model, lags=1,
priors = bv_priors(),
mh = bv_mh(),
n_thin=5, n_burn=5000, n_draw=25000)
zerosign_restr_bvar <- zerosign_restr.bvar(bvar_model,
restr_matrix = signs,
LR = FALSE, tries = 1000)
debugonce(zerosign_restr_ala_arias)
zerosign_restr_bvar <- zerosign_restr.bvar(bvar_model,
restr_matrix = signs,
LR = FALSE, tries = 1000)
S_j
irfs
Q[,j]
S_j %*% irfs %*% Q[,j]
irfs %*% Q[,j]
zerosign_restr_bvar <- zerosign_restr.bvar(bvar_model,
restr_matrix = signs,
LR = FALSE, tries = 1000)
signs <- array(NA, dim=c(nvars, nvars, horizon))
#supply shocks
signs[1,1,1:2] <- 1 #self
signs[2,1,1:2] <- -1 #inflation
signs[5,1,1] <- 0 #oil
#demand shocks
signs[2,2,1:2] <- 1 #self
signs[1,2,1:2] <- 1 #gdp
signs[3,2,1:2] <- 1 #intrate
signs[4,2,1:2] <- -1 #exrate (versatile)
signs[5,2,1] <- 0 #oil
#monetary shocks
signs[3,3,1:2] <- 1 #self
signs[1,3,1:2] <- -1 #gdp
signs[2,3,1:2] <- -1 #inflation
signs[4,3,1:2] <- -1 #exrate
signs[5,3,1] <- 0 #oil
#exrate shocks
signs[4,4,1:2] <- 1 #self
signs[2,4,1:2] <- 1 #inflation
signs[3,4,1:2] <- 1 #monetary
signs[5,4,1] <- 0 #oil
#oil shocks
signs[5,5,1:2] <- 1 #self
signs[4,5,1] <- -1 #exrate
bvar_model <- bvar(data_to_model, lags=1,
priors = bv_priors(),
mh = bv_mh(),
n_thin=5, n_burn=5000, n_draw=15000)
zerosign_restr_bvar <- zerosign_restr.bvar(bvar_model,
restr_matrix = signs,
LR = FALSE, tries = 1000)
bvar
set.seed(1234567)
bvar_model <- bvar(data_to_model, lags=1,
priors = bv_priors(hyper="full"),
mh = bv_mh(),
n_thin=5, n_burn=5000, n_draw=15000)
zerosign_restr_bvar <- zerosign_restr.bvar(bvar_model,
restr_matrix = signs,
LR = FALSE, tries = 1000)
irf(bvar_model)
plot(irf(bvar_model))
#Zero and sign matrix
horizon <- 2
nvars <- NCOL(data_to_model)
signs <- array(NA, dim=c(nvars, nvars, horizon))
#supply shocks
signs[1,1,1:2] <- 1 #self
signs[2,1,1:2] <- -1 #inflation
signs[5,1,1] <- 0 #oil
#demand shocks
signs[2,2,1:2] <- 1 #self
signs[1,2,1:2] <- 1 #gdp
signs[3,2,1:2] <- 1 #intrate
#signs[4,2,1:2] <- -1 #exrate (versatile)
signs[5,2,1] <- 0 #oil
#monetary shocks
signs[3,3,1:2] <- 1 #self
signs[1,3,1:2] <- -1 #gdp
signs[2,3,1:2] <- -1 #inflation
signs[4,3,1:2] <- -1 #exrate
signs[5,3,1] <- 0 #oil
#exrate shocks
signs[4,4,1:2] <- 1 #self
signs[2,4,1:2] <- 1 #inflation
signs[3,4,1:2] <- 1 #monetary
signs[5,4,1] <- 0 #oil
#oil shocks
signs[5,5,1:2] <- 1 #self
signs[4,5,1] <- -1 #exrate
source('~/ВШЭ/Магистратура/Thesis/ZeroSignR/package/ZerosignR/R/irf_ala_arias.R')
zerosign_restr_bvar <- zerosign_restr.bvar(bvar_model,
restr_matrix = signs,
LR = FALSE, tries = 1000)
signs_test
zerosign_restr_bvar <- zerosign_restr.bvar(bvar_model,
restr_matrix = signs_test,
LR = FALSE, tries = 1000)
irf_ala_arias <- function(B, Sigma, p, n, horizon, LR=FALSE, Q=NULL){
#' Calculate structural IRFs
#'
#' This function calculates orthogonal structural IRFs
#' using linear algebra primitives. Returns a \eqn{n \times (n \cdot horizon + n \cdot 1_{LR})}{n x (n*horizon + 1*LR)} matrix,
#' columns of which represent shocks, as ordered in model, and rows represent variables for each period of
#' IRF, as ordered in model, written cyclically. First n rows represent contemporaneous relations of
#' variables, next n rows represent same relations for h=1, and so on.
#'
#' @param B \eqn{B = A_+ \cdot (A_0)^(-1)}{B = A+ * A0^(-1)} --- matrix of reduced parameters in form \eqn{B = \left[c, B_1, \ldots, B_p \right]}{B = (c, B1, ..., Bp)}.
#' If there are no constants in model, just add extra zero column to the beginning of B.
#' @param Sigma Variance-covariance matrix of error term.
#' @param p Order of model.
#' @param n Number of variables/shocks, including unidentified ones.
#' @param horizon Number of periods to calculate IRF for. -1 => no short-run IRFs.
#' @param LR Boolean variable, whether to calculate long-run IRF (default=FALSE). Note if LR is TRUE, long-run IRFs.
#' are added to the bottom of matrix returned (the last n rows are long-run IRFs).
#' @param Q \emph{(optional)} Estimated orthonormal matrix used for structural IRF (default=NULL).
#' @return A matrix of columnwise-stacked structural IRFs, columns = shocks (as ordered in model), rows = variables*horizon.
require(expm)
A0_inv = chol(Sigma)
A0 = solve(A0_inv)
A_plus = B %*% A0
if(horizon >=0){
#Finite-run IRFs
F_mat = matrix(data=0, nrow = p*n, ncol = p*n)
F_mat[,1:n] = t(B[-1,])
if(p > 1){
F_mat[1:((p-1)*n), (n+1):NCOL(F_mat)] = diag(nrow=(p-1)*n, ncol = (p-1)*n)
}
J_mat = matrix(data=0, nrow=p*n, ncol=n)
J_mat[1:n, 1:n] = diag(nrow=n, ncol=n)
irfs = matrix(nrow=(horizon+1)*n, ncol=n)
for(time in 0:horizon){
irfs[(1 + n*(time)):(n*(time+1)),] =
A0_inv %*% t(J_mat) %*% (F_mat %^%(time)) %*% J_mat
#delete A0_inv to get usual Phi
#otherwise, get already Cholesky ortho IRFs
}
}
else{
irfs = matrix(nrow=0, ncol=n)
}
if(LR){
#Long-run IRFs
A_sum = 0
for(lag in 1:p){
A_sum = A_sum + t(A_plus)[1:n, ((2 + n*(lag-1)):(1 + n*lag))]
}
irfs_lr <- solve(t(A0) - A_sum)
irfs <- rbind(irfs, irfs_lr)
}
if(!is.null(Q)){
stopifnot("Orthonormal matrix Q should be square!"= NROW(Q) == NCOL(Q))
stopifnot("Number of variables and dimension of matrix Q are incompatible."= NCOL(irfs)==NCOL(Q))
irfs = irfs %*% Q
}
return(irfs)
}
zerosign_restr_bvar <- zerosign_restr.bvar(bvar_model,
restr_matrix = signs_test,
LR = FALSE, tries = 1000)
source('~/ВШЭ/Магистратура/Thesis/ZeroSignR/package/ZerosignR/R/irf_ala_arias.R')
zerosign_restr_bvar <- zerosign_restr.bvar(bvar_model,
restr_matrix = signs_test,
LR = FALSE, tries = 1000)
source('~/ВШЭ/Магистратура/Thesis/ZeroSignR/package/ZerosignR/R/irf_ala_arias.R')
zerosign_restr_bvar <- zerosign_restr.bvar(bvar_model,
restr_matrix = signs_test,
LR = FALSE, tries = 1000)
irf_ala_arias <- function(B, Sigma, p, n, horizon, LR=FALSE, Q=NULL){
#' Calculate structural IRFs
#'
#' This function calculates orthogonal structural IRFs
#' using linear algebra primitives. Returns a \eqn{n \times (n \cdot horizon + n \cdot 1_{LR})}{n x (n*horizon + 1*LR)} matrix,
#' columns of which represent shocks, as ordered in model, and rows represent variables for each period of
#' IRF, as ordered in model, written cyclically. First n rows represent contemporaneous relations of
#' variables, next n rows represent same relations for h=1, and so on.
#'
#' @param B \eqn{B = A_+ \cdot (A_0)^(-1)}{B = A+ * A0^(-1)} --- matrix of reduced parameters in form \eqn{B = \left[c, B_1, \ldots, B_p \right]}{B = (c, B1, ..., Bp)}.
#' If there are no constants in model, just add extra zero column to the beginning of B.
#' @param Sigma Variance-covariance matrix of error term.
#' @param p Order of model.
#' @param n Number of variables/shocks, including unidentified ones.
#' @param horizon Number of periods to calculate IRF for. -1 => no short-run IRFs.
#' @param LR Boolean variable, whether to calculate long-run IRF (default=FALSE). Note if LR is TRUE, long-run IRFs.
#' are added to the bottom of matrix returned (the last n rows are long-run IRFs).
#' @param Q \emph{(optional)} Estimated orthonormal matrix used for structural IRF (default=NULL).
#' @return A matrix of columnwise-stacked structural IRFs, columns = shocks (as ordered in model), rows = variables*horizon.
require(expm)
A0_inv = chol(Sigma)
A0 = solve(A0_inv)
cat(A0)
stop()
A_plus = B %*% A0
if(horizon >=0){
#Finite-run IRFs
F_mat = matrix(data=0, nrow = p*n, ncol = p*n)
F_mat[,1:n] = t(B[-1,])
if(p > 1){
F_mat[1:((p-1)*n), (n+1):NCOL(F_mat)] = diag(nrow=(p-1)*n, ncol = (p-1)*n)
}
J_mat = matrix(data=0, nrow=p*n, ncol=n)
J_mat[1:n, 1:n] = diag(nrow=n, ncol=n)
irfs = matrix(nrow=(horizon+1)*n, ncol=n)
for(time in 0:horizon){
irfs[(1 + n*(time)):(n*(time+1)),] =
A0_inv %*% t(J_mat) %*% (F_mat %^%(time)) %*% J_mat
#delete A0_inv to get usual Phi
#otherwise, get already Cholesky ortho IRFs
}
}
else{
irfs = matrix(nrow=0, ncol=n)
}
if(LR){
#Long-run IRFs
A_sum = 0
for(lag in 1:p){
A_sum = A_sum + t(A_plus)[1:n, ((2 + n*(lag-1)):(1 + n*lag))]
}
irfs_lr <- solve(t(A0) - A_sum)
irfs <- rbind(irfs, irfs_lr)
}
if(!is.null(Q)){
stopifnot("Orthonormal matrix Q should be square!"= NROW(Q) == NCOL(Q))
stopifnot("Number of variables and dimension of matrix Q are incompatible."= NCOL(irfs)==NCOL(Q))
irfs = irfs %*% Q
}
return(irfs)
}
zerosign_restr_bvar <- zerosign_restr.bvar(bvar_model,
restr_matrix = signs_test,
LR = FALSE, tries = 1000)
load_all()
devtools::load_all()
rm(list = c("irf_ala_arias"))
devtools::load_all()
zerosign_restr_bvar <- zerosign_restr.bvar(bvar_model,
restr_matrix = signs_test,
LR = FALSE, tries = 1000)
zerosign_restr_bvar <- zerosign_restr.bvar(bvar_model,
restr_matrix = signs_test,
LR = FALSE, tries = 1000)
devtools::load_all()
zerosign_restr_bvar <- zerosign_restr.bvar(bvar_model,
restr_matrix = signs_test,
LR = FALSE, tries = 1000)
zerosign_restr_bvar <- zerosign_restr.bvar(bvar_model,
restr_matrix = signs_test,
LR = FALSE, tries = 1000)
devtools::load_all()
zerosign_restr_bvar <- zerosign_restr.bvar(bvar_model,
restr_matrix = signs_test,
LR = FALSE, tries = 1000)
signs_test
zerosign_restr_bvar <- zerosign_restr.bvar(bvar_model,
restr_matrix = signs,
LR = FALSE, tries = 1000)
devtools::load_all()
zerosign_restr_bvar <- zerosign_restr.bvar(bvar_model,
restr_matrix = signs,
LR = FALSE, tries = 1000)
devtools::load_all()
zerosign_restr_bvar <- zerosign_restr.bvar(bvar_model,
restr_matrix = signs,
LR = FALSE, tries = 1000)
zerosign_restr_bvar <- zerosign_restr.bvar(bvar_model,
restr_matrix = signs_test,
LR = FALSE, tries = 1000)
zerosign_restr_bvar <- zerosign_restr.bvar(bvar_model,
restr_matrix = signs,
LR = FALSE, tries = 1000)
bvar_model <- bvar(data_to_model, lags=1,
priors = bv_priors(hyper="full"),
mh = bv_mh(),
n_thin=2, n_burn=8000, n_draw=10000)
zerosign_restr_bvar <- zerosign_restr.bvar(bvar_model,
restr_matrix = signs_test,
LR = FALSE, tries = 10000)
zerosign_restr_bvar <- zerosign_restr.bvar(bvar_model,
restr_matrix = signs,
LR = FALSE, tries = 10000)
debug(zerosign_restr_ala_arias)
zerosign_restr_bvar <- zerosign_restr.bvar(bvar_model,
restr_matrix = signs,
LR = FALSE, tries = 1000)
debug(zerosign_restr_ala_arias)
zerosign_restr_bvar <- zerosign_restr.bvar(bvar_model,
restr_matrix = signs,
LR = FALSE, tries = 1000)
View(Q)
irfs %*% Q[,j]
irfs%*%Q
S_j %*% irfs %*% Q[,j]
S
S * (irfs %*% Q)
View(S)
irfs
debug(irf_ala_arias)
zerosign_restr_bvar <- zerosign_restr.bvar(bvar_model,
restr_matrix = signs,
LR = FALSE, tries = 1000)
A0
A0_inv
A0
irfs
zerosign_restr_bvar <- zerosign_restr.bvar(bvar_model,
restr_matrix = signs,
LR = FALSE, tries = 1000)
A0_inv = t(chol(Sigma))
irfs
chol(Sigma)
irf.bvar
library(bvar)
library(BVAR)
irf.bvar
zerosign_restr_bvar <- zerosign_restr.bvar(bvar_model,
restr_matrix = signs,
LR = FALSE, tries = 1000)
irfs
devtools::load_all()
zerosign_restr_bvar <- zerosign_restr.bvar(bvar_model,
restr_matrix = signs,
LR = FALSE, tries = 1000)
irfs
zerosign_restr_bvar <- zerosign_restr.bvar(bvar_model,
restr_matrix = signs_test,
LR = FALSE, tries = 1000)
irfs
zerosign_restr_bvar <- zerosign_restr.bvar(bvar_model,
restr_matrix = signs_test,
LR = FALSE, tries = 1000)
satisfying_models
irfs_transformed
signs_test
signs_test[5,1,1] <- 0
zerosign_restr_bvar <- zerosign_restr.bvar(bvar_model,
restr_matrix = signs_test,
LR = FALSE, tries = 1000)
irfs_transformed
signs_test[5,1,2] <- 0
zerosign_restr_bvar <- zerosign_restr.bvar(bvar_model,
restr_matrix = signs_test,
LR = FALSE, tries = 1000)
satisfying_models
irfs
irfs
devtools::load_all()
zerosign_restr_bvar <- zerosign_restr.bvar(bvar_model,
restr_matrix = signs_test,
LR = FALSE, tries = 1000)
zerosign_restr_bvar <- zerosign_restr.bvar(bvar_model,
restr_matrix = signs,
LR = FALSE, tries = 1000)
#Zero and sign matrix
horizon <- 2
nvars <- NCOL(data_to_model)
signs <- array(NA, dim=c(nvars, nvars, horizon))
#supply shocks
signs[1,1,1:2] <- 1 #self
signs[2,1,1:2] <- -1 #inflation
signs[5,1,1] <- 0 #oil
#demand shocks
signs[2,2,1:2] <- 1 #self
signs[1,2,1:2] <- 1 #gdp
signs[3,2,1:2] <- 1 #intrate
signs[4,2,1:2] <- -1 #exrate (versatile)
signs[5,2,1] <- 0 #oil
#monetary shocks
signs[3,3,1:2] <- 1 #self
signs[1,3,1:2] <- -1 #gdp
signs[2,3,1:2] <- -1 #inflation
signs[4,3,1:2] <- -1 #exrate
signs[5,3,1] <- 0 #oil
#exrate shocks
signs[4,4,1:2] <- 1 #self
signs[2,4,1:2] <- 1 #inflation
signs[3,4,1:2] <- 1 #monetary
signs[5,4,1] <- 0 #oil
#oil shocks
signs[5,5,1:2] <- 1 #self
signs[4,5,1] <- -1 #exrate
zerosign_restr_bvar <- zerosign_restr.bvar(bvar_model,
restr_matrix = signs,
LR = FALSE, tries = 1000)
#Zero and sign matrix
horizon <- 2
nvars <- NCOL(data_to_model)
signs <- array(NA, dim=c(nvars, nvars, horizon))
#supply shocks
signs[1,1,1:2] <- 1 #self
signs[2,1,1:2] <- -1 #inflation
signs[5,1,1] <- 0 #oil
#demand shocks
signs[2,2,1:2] <- 1 #self
signs[1,2,1:2] <- 1 #gdp
signs[3,2,1:2] <- 1 #intrate
#signs[4,2,1:2] <- -1 #exrate (versatile)
signs[5,2,1] <- 0 #oil
#monetary shocks
signs[3,3,1:2] <- 1 #self
signs[1,3,1:2] <- -1 #gdp
signs[2,3,1:2] <- -1 #inflation
signs[4,3,1:2] <- -1 #exrate
signs[5,3,1] <- 0 #oil
#exrate shocks
signs[4,4,1:2] <- 1 #self
signs[2,4,1:2] <- 1 #inflation
signs[3,4,1:2] <- 1 #monetary
signs[5,4,1] <- 0 #oil
#oil shocks
signs[5,5,1:2] <- 1 #self
signs[4,5,1:2] <- -1 #exrate
zerosign_restr_bvar <- zerosign_restr.bvar(bvar_model,
restr_matrix = signs,
LR = FALSE, tries = 1000)
Rprof()
zerosign_restr_bvar <- zerosign_restr.bvar(bvar_model,
restr_matrix = signs,
LR = FALSE, tries = 1000)
Rprof(NULL)
summaryRprof()
set.seed(1234567)
zerosign_restr_bvar <- zerosign_restr.bvar(bvar_model,
restr_matrix = signs,
LR = FALSE, tries = 1000)
ts.plot
devtools::load_all()
irf_zerosign_bvar <- irf(zerosign_restr_bvar)
irf_zerosign_bvar.ZerosignR.result <- irf(zerosign_restr_bvar)
irf_zerosign_bvar <- irf.ZerosignR.result(zerosign_restr_bvar)
irf_zerosign_bvar
devtools::load_all()
irf_zerosign_bvar <- irf.ZerosignR.result(zerosign_restr_bvar)
irf_zerosign_bvar
ts.plot(irf_zerosign_bvar$median_irf[,1])
ts.plot(irf_zerosign_bvar$median_irf[,2])
ts.plot(irf_zerosign_bvar$median_irf[,3])
irf_zerosign_bvar <- irf.ZerosignR.result(zerosign_restr_bvar, horizon = 10)
devtools::load_all()
git
install.packages("learnr")
